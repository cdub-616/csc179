// We're using an alias is because it gives us a consistent key with which to access the value in
// the query result, simplifies codegen AND UI code (and usage within react-json-schema-form)
// The literal value of the alias also shows up in the UI as the name of the field they're editing
export const SCALAR_VALUE_ALIAS = 'value';
// Underscores aren't allowed in entity names so we're safe to use
//  this simple separator in our generated query names.
// Pattern is <entity>__<operation>, eg query Product__get { ... }
const queryNameSeparator = '__';
/*
 * Possible data shapes for a given entity:
 * 1. top-level array of objects with properties (most common)
 * 2. top-level array of some scalar type (e.g. string, number, boolean) - properties will be null
 * 3. top-level object with properties
 * 4. top-level scalar type - properties will be null
 *
 * These each have slightly different query/mutation formats
 * */
export const topLevelTypes = {
    ARRAY_OF_OBJECTS: 'ARRAY_OF_OBJECTS',
    ARRAY_OF_SCALARS: 'ARRAY_OF_SCALARS',
    OBJECT: 'OBJECT',
    SCALAR: 'SCALAR',
};
function getTopLevelType(value) {
    if (value.type === 'array' && value?.items?.type !== 'object') {
        return topLevelTypes.ARRAY_OF_SCALARS;
    }
    if (value.type === 'array' && value?.items?.type === 'object') {
        return topLevelTypes.ARRAY_OF_OBJECTS;
    }
    if (value.type === 'object') {
        return topLevelTypes.OBJECT;
    }
    if (value.type === 'string' ||
        value.type === 'number' ||
        value.type === 'boolean' ||
        value.type === 'null' // Technically possible according to JSON schema, but unlikely
    ) {
        return topLevelTypes.SCALAR;
    }
    throw new Error('Unsupported top-level type');
}
export function getEntitiesFromJsonSchema(schema) {
    const entitiesWithAcl = Object.values(schema?.['x-vendia-acls'] ?? {}).reduce((acc, { type }) => {
        acc[type] = true;
        return acc;
    }, {});
    const entities = {};
    Object.entries(schema.properties).forEach(([name, value]) => {
        entities[name] = {
            type: value.type,
            description: value.description,
            properties: value?.items?.properties ?? value?.properties ?? null,
            hasAcl: entitiesWithAcl[name] ?? false,
            topLevelType: getTopLevelType(value),
        };
    });
    return entities;
}
export function getResultFields({ properties, insertTypename }) {
    const propertyEntries = Object.entries(properties);
    if (insertTypename) {
        propertyEntries.unshift(['__typename', { type: 'string' }]);
    }
    return propertyEntries.map(([propertyName, propertyValue]) => {
        if (propertyValue.type === 'array' && propertyValue.items?.type === 'object') {
            return `${propertyName} {
        ${getResultFields({ properties: propertyValue.items.properties })}
      }`;
        }
        if (propertyValue.type === 'object' && Object.keys(propertyValue?.properties).length > 0) {
            return `${propertyName} {
        ${getResultFields({ properties: propertyValue.properties })}
      }`;
        }
        return propertyName;
    }).join(`
  `);
}
function getResult(entity, entities, schemaNamespace, isTopLevelArrayType) {
    return `{
          ${isTopLevelArrayType ? `_id` : ''}
          _owner
          ${getResultFields({ properties: entities[entity].properties })}
        }`;
}
function getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArrayType) {
    // TODO: "partial union" deprecation in process, for now we still return union type but just use normal type (not partial typed side of union)
    return `{
            ... on ${schemaNamespace}_${entity} {
              ${isTopLevelArrayType ? `_id` : ''}
              _owner
              ${getResultFields({ properties: entities[entity].properties })}
            }
          }`;
}
function getResultForScalarType(entity, schemaNamespace, isTopLevelArrayType) {
    if (!isTopLevelArrayType) {
        return '';
    }
    return `{
            _id
            ${SCALAR_VALUE_ALIAS}: ${schemaNamespace}_${entity}
          }`;
}
export function generateGetOperation({ entity, entities, schemaNamespace }) {
    const topLevelType = entities?.[entity]?.topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const hasAcl = entities[entity].hasAcl;
    let params = isTopLevelArray
        ? '(id: $id, version: $version, readMode: $readMode)'
        : '(version: $version, readMode: $readMode)';
    let paramTypes = isTopLevelArray
        ? '($id: ID!, $version: Int, $readMode: Vendia_ReadMode = NODE_COMMITTED)'
        : '($version: Int, $readMode: Vendia_ReadMode = NODE_COMMITTED)';
    if (topLevelType === topLevelTypes.SCALAR) {
        params = '';
        paramTypes = '';
    }
    let resultContent;
    if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, isTopLevelArray);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
    }
    return `
        query ${entity}${queryNameSeparator}get ${paramTypes}{
          get_${entity}${params} ${resultContent}
        }`;
}
function generateGetOperations(entities, schema, schemaNamespace) {
    const queryTemplates = Object.keys(entities).map((entity) => {
        return generateGetOperation({ entity, entities, schema, schemaNamespace });
    });
    return queryTemplates.join('\n\n');
}
export function generateListOperation({ entity, entities, schemaNamespace }) {
    if (entities[entity].topLevelType === topLevelTypes.SCALAR ||
        entities[entity].topLevelType === topLevelTypes.OBJECT) {
        // Skipping list operation for top-level types that aren't arrays
        return;
    }
    const topLevelType = entities?.[entity]?.topLevelType;
    const hasAcl = entities[entity].hasAcl;
    const filterType = `${schemaNamespace}_${entity}_FilterInput_`;
    const orderType = `[${schemaNamespace}_${entity}_OrderInput_!]`;
    const entityPlural = `_${entity}Items`;
    let resultContent;
    if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, true);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, true);
    }
    return `
          query ${entity}${queryNameSeparator}list($nextToken: String, $limit: Int, $filter: ${filterType}, $order: ${orderType}, $readMode: Vendia_ReadMode = NODE_COMMITTED) {
            list${entityPlural}(nextToken: $nextToken, limit: $limit, filter: $filter, order: $order, readMode: $readMode) {
              ${entityPlural} ${resultContent}
              nextToken
            }
          }`;
}
function generateListOperations(entities, schema, schemaNamespace) {
    const queryTemplates = Object.keys(entities).map((entity) => {
        return generateListOperation({ entity, entities, schema, schemaNamespace });
    });
    return queryTemplates.join('\n\n');
}
/// MUTATION STUFF
const jsonToGglType = {
    number: 'Float',
    string: 'String',
    boolean: 'Boolean',
};
function getTopLevelScalarOrObjectTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
    const inputSuffix = prefix === 'create' ? 'Input' : 'UpdateInput';
    const inputType = topLevelType === topLevelTypes.SCALAR ? jsonToGglType[type] : `${schemaNamespace}_${entity}_${inputSuffix}_`;
    const conditionParamType = prefix === 'create' ? '' : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
    const conditionParam = prefix === 'create' ? '' : ', condition: $condition';
    const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : '';
    const aclParam = hasAcl ? ', aclInput: $aclInput' : '';
    let resultContent;
    if (topLevelType === topLevelTypes.SCALAR) {
        resultContent = getResultForScalarType(entity, schemaNamespace, false);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, false);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, false);
    }
    return `mutation ${entity}${queryNameSeparator}${prefix} ($input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
// handle array of scalars
function getTopLevelArrayTemplate({ prefix, type, topLevelType, hasAcl, entity, schemaNamespace, entities }) {
    const inputSuffix = prefix === 'put' || prefix === 'add' ? 'Input' : 'UpdateInput';
    const idParamType = prefix === 'add' ? '' : '$id: ID!,';
    const idParam = prefix === 'add' ? '' : 'id: $id,';
    const inputType = topLevelType === topLevelTypes.ARRAY_OF_SCALARS
        ? jsonToGglType[type]
        : `${schemaNamespace}_${entity}_${inputSuffix}_`;
    const conditionParamType = prefix === 'add' ? '' : `, $condition: ${schemaNamespace}_${entity}_ConditionInput_`;
    const conditionParam = prefix === 'add' ? '' : ', condition: $condition';
    const aclParamType = hasAcl ? `, $aclInput: Vendia_Acls_Input_` : '';
    const aclParam = hasAcl ? ', aclInput: $aclInput' : '';
    let resultContent;
    if (topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
        resultContent = getResultForScalarType(entity, schemaNamespace, true);
    }
    else if (hasAcl) {
        resultContent = getResultForAclEnabled(entity, entities, schemaNamespace, true);
    }
    else {
        resultContent = getResult(entity, entities, schemaNamespace, true);
    }
    return `mutation ${entity}${queryNameSeparator}${prefix} (${idParamType} $input: ${inputType}!, $syncMode: Vendia_SyncMode = NODE_COMMITTED${conditionParamType}${aclParamType}) {
    ${prefix}_${entity}(${idParam} input: $input, syncMode: $syncMode${conditionParam}${aclParam}) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
      result ${resultContent}
    }
  }`;
}
function getEntityInfo({ entity, entities, schema }) {
    const topLevelType = entities?.[entity]?.topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const type = isTopLevelArray ? schema?.properties?.[entity]?.items?.type : schema?.properties?.[entity]?.type;
    const hasAcl = entities[entity].hasAcl;
    return {
        topLevelType,
        isTopLevelArray,
        type,
        hasAcl,
    };
}
// Add (or Create)
export function generateAddOperation({ entity, entities, schema, schemaNamespace }) {
    const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
    const options = {
        prefix: isTopLevelArray ? 'add' : 'create',
        topLevelType,
        type,
        hasAcl,
        entity,
        entities,
        schemaNamespace,
    };
    return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
export function generateUpdateOperation({ entity, entities, schema, schemaNamespace }) {
    const { isTopLevelArray, topLevelType, type, hasAcl } = getEntityInfo({ entity, entities, schema });
    const options = {
        prefix: 'update',
        topLevelType,
        type,
        hasAcl,
        entity,
        entities,
        schemaNamespace,
    };
    return isTopLevelArray ? getTopLevelArrayTemplate(options) : getTopLevelScalarOrObjectTemplate(options);
}
function generateCreateUpdateMutations(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        // Skipping put for now, because aclInput requirement makes it tricky... becomes a third, required, option in SDK
        // templates.push(getTopLevelArrayTemplate({ prefix: 'put', type, entity, schemaNamespace, topLevelType,hasAcl }))
        const templates = [
            generateAddOperation({ entity, entities, schema, schemaNamespace }),
            generateUpdateOperation({ entity, entities, schema, schemaNamespace }),
        ];
        return templates.join('\n\n');
    });
    return mutationTemplates.join('\n\n');
}
export function generateDeleteOperation({ entity, entities, schemaNamespace }) {
    const topLevelType = entities[entity].topLevelType;
    const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
    const operationName = isTopLevelArray ? 'remove' : 'delete';
    const idParamType = !isTopLevelArray ? '' : '$id: ID!,';
    const idParam = !isTopLevelArray ? '' : 'id: $id,';
    return `mutation ${entity}${queryNameSeparator}${operationName} (${idParamType} $syncMode: Vendia_SyncMode = NODE_COMMITTED, $condition: ${schemaNamespace}_${entity}_ConditionInput_) {
    ${operationName}_${entity}(${idParam} syncMode: $syncMode, condition: $condition) {
      transaction {
        _id
        _owner
        transactionId
        submissionTime
        version
      }
    }
  }`;
}
function generateDeleteMutations(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        return generateDeleteOperation({ entity, entities, schema, schemaNamespace });
    });
    return mutationTemplates.join('\n\n');
}
function generateSubscriptions(entities, schema, schemaNamespace) {
    const mutationTemplates = Object.keys(entities).map((entity) => {
        const topLevelType = entities[entity].topLevelType;
        const isTopLevelArray = topLevelType === topLevelTypes.ARRAY_OF_OBJECTS || topLevelType === topLevelTypes.ARRAY_OF_SCALARS;
        let resultContent;
        if (topLevelType === topLevelTypes.SCALAR || topLevelType === topLevelTypes.ARRAY_OF_SCALARS) {
            resultContent = getResultForScalarType(entity, schemaNamespace, isTopLevelArray);
        }
        else {
            resultContent = getResult(entity, entities, schemaNamespace, isTopLevelArray);
        }
        function getSubscriptionTemplate(operationName) {
            // Scalar just returns value, no id or error field - strange, but true
            // Refactor to use getResultForScalarType and merge with ARRAY_OF_SCALARS case below if this ever changes
            if (topLevelType === topLevelTypes.SCALAR) {
                return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity}
    }`;
            }
            // TODO - update if/when we update subscription return types for ACL-enabled entities (no union with partial at the moment)
            return `subscription ${entity}${queryNameSeparator}on${operationName} {
      on${operationName}_${entity} {
        error
        result ${resultContent}
      }
    }`;
        }
        let operations = ['Create', 'Delete', 'Update'];
        if (isTopLevelArray) {
            operations = ['Add', 'Remove', 'Update'];
        }
        return operations.map((operation) => getSubscriptionTemplate(operation)).join('\n\n');
    });
    return mutationTemplates.join('\n\n');
}
export const generateEntityOperations = (schema, schemaNamespace) => {
    const schemaEntities = getEntitiesFromJsonSchema(schema);
    return (generateGetOperations(schemaEntities, schema, schemaNamespace) +
        generateListOperations(schemaEntities, schema, schemaNamespace) +
        generateCreateUpdateMutations(schemaEntities, schema, schemaNamespace) +
        generateDeleteMutations(schemaEntities, schema, schemaNamespace) +
        generateSubscriptions(schemaEntities, schema, schemaNamespace));
};
