export interface TrackedHook {
    target: string;
    pkg: string;
}
declare class HookTracker {
    private _applied;
    private _available;
    private _notApplied;
    print(): void;
    categorizeUnknown(requestedHooks: Hook[]): this;
    clear(): void;
    addApplied(pkg: string, target: string): void;
    addAvailable(pkg: string, target: string): void;
    addNotApplied(pkg: string, target: string): void;
    get applied(): TrackedHook[];
    get available(): TrackedHook[];
    get notApplied(): TrackedHook[];
}
export declare function logHooks(hooks: Hook[]): void;
export declare const hookTracker: HookTracker;
export declare enum HookType {
    Before = 0,
    After = 1,
    Replace = 2
}
export type BeforeHookFn = (thisPtr: any, params: any[], hookId: number) => any;
export type ReplaceHookFn = (thisPtr: any, params: any[], hookId: number, origFn: Function) => any;
export type AfterHookFn = (thisPtr: any, params: any[], hookId: number, result: any) => any;
export type HookFn = BeforeHookFn | ReplaceHookFn | AfterHookFn;
export declare class Hook {
    readonly type: HookType;
    readonly target: string;
    readonly pkg: string;
    readonly async: boolean;
    readonly hookFunction: HookFn;
    constructor(type: HookType, target: string, pkg: string, async: boolean, hookFunction: HookFn);
    match(pkg: string, target: string): boolean;
}
export {};
