"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.hookBuiltInFunction = exports.registerAfterHook = exports.registerReplaceHook = exports.registerBeforeHook = exports.hookManager = exports.callSiteId = exports.HookManager = exports.MatchingHooksResult = void 0;
const hook_1 = require("./hook");
class MatchingHooksResult {
    beforeHooks = [];
    replaceHooks = [];
    afterHooks = [];
    addHook(h) {
        switch (h.type) {
            case hook_1.HookType.Before:
                this.beforeHooks.push(h);
                break;
            case hook_1.HookType.Replace:
                this.replaceHooks.push(h);
                break;
            case hook_1.HookType.After:
                this.afterHooks.push(h);
                break;
        }
    }
    verify() {
        if (this.replaceHooks.length > 1) {
            throw new Error(`For a given target function, one REPLACE hook can be configured. Found: ${this.replaceHooks.length}`);
        }
        if (this.hasReplaceHooks() &&
            (this.hasBeforeHooks() || this.hasAfterHooks())) {
            throw new Error(`For a given target function, REPLACE hooks cannot be mixed up with BEFORE/AFTER hooks. Found ${this.replaceHooks.length} REPLACE hooks and ${this.beforeHooks.length + this.afterHooks.length} BEFORE/AFTER hooks`);
        }
        if (this.hasAfterHooks()) {
            if (!this.afterHooks.every((h) => h.async) &&
                !this.afterHooks.every((h) => !h.async)) {
                throw new Error("For a given target function, AFTER hooks have to be either all sync or all async.");
            }
        }
    }
    hooks() {
        return this.beforeHooks.concat(this.afterHooks, this.replaceHooks);
    }
    hasHooks() {
        return (this.hasBeforeHooks() || this.hasReplaceHooks() || this.hasAfterHooks());
    }
    hasBeforeHooks() {
        return this.beforeHooks.length !== 0;
    }
    hasReplaceHooks() {
        return this.replaceHooks.length !== 0;
    }
    hasAfterHooks() {
        return this.afterHooks.length !== 0;
    }
}
exports.MatchingHooksResult = MatchingHooksResult;
class HookManager {
    _hooks = [];
    registerHook(hookType, target, pkg, async, hookFn) {
        const hook = new hook_1.Hook(hookType, target, pkg, async, hookFn);
        this._hooks.push(hook);
        return hook;
    }
    get hooks() {
        return this._hooks;
    }
    clearHooks() {
        this._hooks = [];
    }
    hookIndex(hook) {
        return this._hooks.indexOf(hook);
    }
    matchingHooks(target, filepath) {
        const matches = this._hooks
            .filter((hook) => hook.match(filepath, target))
            .reduce((matches, hook) => {
            matches.addHook(hook);
            return matches;
        }, new MatchingHooksResult());
        matches.verify();
        return matches;
    }
    hasFunctionsToHook(filepath) {
        return (this._hooks.find((hook) => filepath.includes(hook.pkg)) !== undefined);
    }
    getMatchingHooks(filepath) {
        return this._hooks.filter((hook) => filepath.includes(hook.pkg));
    }
    callHook(id, thisPtr, params, resultOrOriginalFunction) {
        const hook = this._hooks[id];
        switch (hook.type) {
            case hook_1.HookType.Before:
                hook.hookFunction(thisPtr, params, callSiteId());
                break;
            case hook_1.HookType.Replace:
                return hook.hookFunction(thisPtr, params, callSiteId(), 
                // eslint-disable-next-line @typescript-eslint/ban-types
                resultOrOriginalFunction);
            case hook_1.HookType.After:
                hook.hookFunction(thisPtr, params, callSiteId(), resultOrOriginalFunction);
        }
    }
}
exports.HookManager = HookManager;
function callSiteId(...additionalArguments) {
    const stackTrace = additionalArguments?.join(",") + new Error().stack;
    if (!stackTrace || stackTrace.length === 0) {
        return 0;
    }
    let hash = 0, i, chr;
    for (i = 0; i < stackTrace.length; i++) {
        chr = stackTrace.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
exports.callSiteId = callSiteId;
exports.hookManager = new HookManager();
// convenience functions to register hooks
function registerBeforeHook(target, pkg, async, hookFn) {
    exports.hookManager.registerHook(hook_1.HookType.Before, target, pkg, async, hookFn);
}
exports.registerBeforeHook = registerBeforeHook;
function registerReplaceHook(target, pkg, async, hookFn) {
    exports.hookManager.registerHook(hook_1.HookType.Replace, target, pkg, async, hookFn);
}
exports.registerReplaceHook = registerReplaceHook;
function registerAfterHook(target, pkg, async, hookFn) {
    exports.hookManager.registerHook(hook_1.HookType.After, target, pkg, async, hookFn);
}
exports.registerAfterHook = registerAfterHook;
/**
 * Replaces a built-in function with a custom implementation while preserving
 * the original function for potential use within the replacement function.
 */
async function hookBuiltInFunction(hook) {
    const { default: module } = await import(hook.pkg);
    const originalFn = module[hook.target];
    const id = callSiteId(exports.hookManager.hookIndex(hook), hook.pkg, hook.target);
    if (hook.type == hook_1.HookType.Before) {
        module[hook.target] = (...args) => {
            hook.hookFunction(null, args, id);
            return originalFn(...args);
        };
    }
    else if (hook.type == hook_1.HookType.Replace) {
        module[hook.target] = (...args) => {
            return hook.hookFunction(null, args, id, originalFn);
        };
    }
    else if (hook.type == hook_1.HookType.After) {
        module[hook.target] = (...args) => {
            const result = originalFn(...args);
            return hook.hookFunction(null, args, id, result);
        };
    }
    else {
        throw new Error(`Unknown hook type ${hook.type}`);
    }
    (0, hook_1.logHooks)([hook]);
    hook_1.hookTracker.addApplied(hook.pkg, hook.target);
}
exports.hookBuiltInFunction = hookBuiltInFunction;
//# sourceMappingURL=manager.js.map