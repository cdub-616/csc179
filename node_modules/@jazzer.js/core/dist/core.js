"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuzzedDataProvider = exports.jazzer = exports.ensureFilepath = exports.wrapFuzzFunctionForBugDetection = exports.startFuzzingNoInit = exports.startFuzzing = exports.registerGlobals = exports.initFuzzing = void 0;
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const path_1 = __importDefault(require("path"));
const process = __importStar(require("process"));
const tmp = __importStar(require("tmp"));
const fs = __importStar(require("fs"));
const libCoverage = __importStar(require("istanbul-lib-coverage"));
const libReport = __importStar(require("istanbul-lib-report"));
const reports = __importStar(require("istanbul-reports"));
const fuzzer = __importStar(require("@jazzer.js/fuzzer"));
const hooking = __importStar(require("@jazzer.js/hooking"));
const bug_detectors_1 = require("@jazzer.js/bug-detectors");
const instrumentor_1 = require("@jazzer.js/instrumentor");
const module_1 = require("module");
// Remove temporary files on exit
tmp.setGracefulCleanup();
// libFuzzer uses exit code 77 in case of a crash, so use a similar one for
// failed error expectations.
const ERROR_EXPECTED_CODE = 0;
const ERROR_UNEXPECTED_CODE = 78;
async function initFuzzing(options) {
    registerGlobals();
    (0, instrumentor_1.registerInstrumentor)(new instrumentor_1.Instrumentor(options.includes, options.excludes, options.customHooks, options.coverage, options.dryRun, options.idSyncFile !== undefined
        ? new instrumentor_1.FileSyncIdStrategy(options.idSyncFile)
        : new instrumentor_1.MemorySyncIdStrategy()));
    // Loads custom hook files and adds them to the hook manager.
    await Promise.all(options.customHooks.map(ensureFilepath).map(importModule));
    // Load built-in bug detectors. Some of them might register hooks with the hook manager.
    // Each bug detector is written in its own file, and theoretically could be loaded in the same way as custom hooks
    // above. However, the path the bug detectors must be the compiled path. For this reason we decided to load them
    // using this function, which loads each bug detector relative to the bug-detectors directory. E.g., in Jazzer
    // (without the .js) there is no distinction between custom hooks and bug detectors.
    await (0, bug_detectors_1.loadBugDetectors)(options.disableBugDetectors.map((pattern) => new RegExp(pattern)));
    // Built-in functions cannot be hooked by the instrumentor, so we manually hook them here.
    await hookBuiltInFunctions(hooking.hookManager);
}
exports.initFuzzing = initFuzzing;
// Built-in functions cannot be hooked by the instrumentor. We hook them by overwriting them at the module level.
async function hookBuiltInFunctions(hookManager) {
    for (const builtinModule of module_1.builtinModules) {
        for (const hook of hookManager.getMatchingHooks(builtinModule)) {
            try {
                await hooking.hookBuiltInFunction(hook);
            }
            catch (e) {
                if (process.env.JAZZER_DEBUG) {
                    console.log("DEBUG: [Hook] Error when trying to hook the built-in function: " +
                        e);
                }
            }
        }
    }
}
function registerGlobals() {
    globalThis.Fuzzer = fuzzer.fuzzer;
    globalThis.HookManager = hooking.hookManager;
}
exports.registerGlobals = registerGlobals;
async function startFuzzing(options) {
    await initFuzzing(options);
    const fuzzFn = await loadFuzzFunction(options);
    await startFuzzingNoInit(fuzzFn, options).then(() => {
        stopFuzzing(undefined, options.expectedErrors, options.coverageDirectory, options.coverageReporters, options.sync);
    }, (err) => {
        stopFuzzing(err, options.expectedErrors, options.coverageDirectory, options.coverageReporters, options.sync);
    });
}
exports.startFuzzing = startFuzzing;
function logInfoAboutFuzzerOptions(fuzzerOptions) {
    fuzzerOptions.slice(1).forEach((element) => {
        if (element.length > 0 && element[0] != "-") {
            console.error("INFO: using inputs from:", element);
        }
    });
}
async function startFuzzingNoInit(fuzzFn, options) {
    const fuzzerOptions = buildFuzzerOptions(options);
    logInfoAboutFuzzerOptions(fuzzerOptions);
    const fuzzerFn = options.sync
        ? Fuzzer.startFuzzing
        : Fuzzer.startFuzzingAsync;
    // Wrap the potentially sync fuzzer call, so that resolve and exception
    // handlers are always executed.
    return Promise.resolve().then(() => fuzzerFn(fuzzFn, fuzzerOptions));
}
exports.startFuzzingNoInit = startFuzzingNoInit;
function prepareLibFuzzerArg0(fuzzerOptions) {
    // When we run in a libFuzzer mode that spawns subprocesses, we create a wrapper script
    // that can be used as libFuzzer's argv[0]. In the fork mode, the main libFuzzer process
    // uses argv[0] to spawn further processes that perform the actual fuzzing.
    const libFuzzerSpawnsProcess = fuzzerOptions.some((flag) => flag.startsWith("-fork=") ||
        flag.startsWith("-jobs=") ||
        flag.startsWith("-merge="));
    if (!libFuzzerSpawnsProcess) {
        // Return a fake argv[0] to start the fuzzer if libFuzzer does not spawn new processes.
        return "unused_arg0_report_a_bug_if_you_see_this";
    }
    else {
        // Create a wrapper script and return its path.
        return createWrapperScript(fuzzerOptions);
    }
}
function createWrapperScript(fuzzerOptions) {
    const jazzerArgs = process.argv.filter((arg) => arg !== "--" && fuzzerOptions.indexOf(arg) === -1);
    if (jazzerArgs.indexOf("--id_sync_file") === -1) {
        const idSyncFile = tmp.fileSync({
            mode: 0o600,
            prefix: "jazzer.js",
            postfix: "idSync",
        });
        jazzerArgs.push("--id_sync_file", idSyncFile.name);
        fs.closeSync(idSyncFile.fd);
    }
    const isWindows = process.platform === "win32";
    const scriptContent = `${isWindows ? "@echo off" : "#!/usr/bin/env sh"}
cd "${process.cwd()}"
${jazzerArgs.map((s) => '"' + s + '"').join(" ")} -- ${isWindows ? "%*" : "$@"}
`;
    const scriptTempFile = tmp.fileSync({
        mode: 0o700,
        prefix: "jazzer.js",
        postfix: "libfuzzer" + (isWindows ? ".bat" : ".sh"),
    });
    fs.writeFileSync(scriptTempFile.name, scriptContent);
    fs.closeSync(scriptTempFile.fd);
    return scriptTempFile.name;
}
function stopFuzzing(err, expectedErrors, coverageDirectory, coverageReporters, sync) {
    const stopFuzzing = sync ? Fuzzer.stopFuzzing : Fuzzer.stopFuzzingAsync;
    if (process.env.JAZZER_DEBUG) {
        hooking.hookTracker.categorizeUnknown(HookManager.hooks).print();
    }
    // Generate a coverage report in fuzzing mode (non-jest). The coverage report for our jest-runner is generated
    // by jest internally (as long as '--coverage' is set).
    if (global.__coverage__) {
        const coverageMap = libCoverage.createCoverageMap(global.__coverage__);
        const context = libReport.createContext({
            dir: coverageDirectory,
            watermarks: {},
            coverageMap: coverageMap,
        });
        coverageReporters.forEach((reporter) => reports.create(reporter).execute(context));
    }
    // No error found, check if one is expected.
    if (!err) {
        if (expectedErrors.length) {
            console.error(`ERROR: Received no error, but expected one of [${expectedErrors}].`);
            stopFuzzing(ERROR_UNEXPECTED_CODE);
        }
        return;
    }
    // Error found and expected, check if it's one of the expected ones.
    if (expectedErrors.length) {
        const name = errorName(err);
        if (expectedErrors.includes(name)) {
            console.error(`INFO: Received expected error "${name}".`);
            stopFuzzing(ERROR_EXPECTED_CODE);
        }
        else {
            printError(err);
            console.error(`ERROR: Received error "${name}" is not in expected errors [${expectedErrors}].`);
            stopFuzzing(ERROR_UNEXPECTED_CODE);
        }
        return;
    }
    // Error found, but no specific one expected. This case is used for normal
    // fuzzing runs, so no dedicated exit code is given to the stop fuzzing function.
    printError(err);
    stopFuzzing();
}
function errorName(error) {
    if (error instanceof Error) {
        // error objects
        return error.name;
    }
    else if (typeof error !== "object") {
        // primitive types
        return String(error);
    }
    else {
        // Arrays and objects can not be converted to a proper name and so
        // not be stated as expected error.
        return "unknown";
    }
}
function printError(error) {
    let errorMessage = `==${process.pid}== `;
    if (!(error instanceof bug_detectors_1.Finding)) {
        errorMessage += "Uncaught Exception: Jazzer.js: ";
    }
    if (error instanceof Error) {
        errorMessage += error.message;
        console.log(errorMessage);
        if (error.stack) {
            console.log(cleanErrorStack(error));
        }
    }
    else if (typeof error === "string" || error instanceof String) {
        errorMessage += error;
        console.log(errorMessage);
    }
    else {
        errorMessage += "unknown";
        console.log(errorMessage);
    }
}
function cleanErrorStack(error) {
    if (error.stack === undefined)
        return "";
    // This cleans up the stack of a finding. The changes are independent of each other, since a finding can be
    // thrown from the hooking library, by the custom hooks, or by the fuzz target.
    if (error instanceof bug_detectors_1.Finding) {
        // Remove the message from the stack trace. Also remove the subsequent line of the remaining stack trace that
        // always contains `reportFinding()`, which is not relevant for the user.
        error.stack = error.stack
            ?.replace(`Error: ${error.message}\n`, "")
            .replace(/.*\n/, "");
        // Remove all lines up to and including the line that mentions the hooking library from the stack trace of a
        // finding.
        const stack = error.stack.split("\n");
        const index = stack.findIndex((line) => line.includes("jazzer.js/packages/hooking/manager"));
        if (index !== undefined && index >= 0) {
            error.stack = stack.slice(index + 1).join("\n");
        }
        // also delete all lines that mention "jazzer.js/packages/"
        error.stack = error.stack.replace(/.*jazzer.js\/packages\/.*\n/g, "");
    }
    const result = [];
    for (const line of error.stack.split("\n")) {
        if (line.includes("jazzer.js/packages/core/core.ts")) {
            break;
        }
        result.push(line);
    }
    return result.join("\n");
}
function buildFuzzerOptions(options) {
    if (!options || !options.fuzzerOptions) {
        return [];
    }
    let opts = options.fuzzerOptions;
    if (options.dryRun) {
        // the last provided option takes precedence
        opts = opts.concat("-runs=0");
    }
    if (options.timeout <= 0) {
        throw new Error("timeout must be > 0");
    }
    const inSeconds = Math.ceil(options.timeout / 1000);
    opts = opts.concat(`-timeout=${inSeconds}`);
    return [prepareLibFuzzerArg0(opts), ...opts];
}
async function loadFuzzFunction(options) {
    const fuzzTarget = await importModule(options.fuzzTarget);
    if (!fuzzTarget) {
        throw new Error(`${options.fuzzTarget} could not be imported successfully"`);
    }
    const fuzzFn = fuzzTarget[options.fuzzEntryPoint];
    if (typeof fuzzFn !== "function") {
        throw new Error(`${options.fuzzTarget} does not export function "${options.fuzzEntryPoint}"`);
    }
    return wrapFuzzFunctionForBugDetection(fuzzFn);
}
/**
 * Wraps the given fuzz target function to handle errors from both the fuzz target and bug detectors.
 * Ensures that errors thrown by bug detectors have higher priority than errors in the fuzz target.
 */
function wrapFuzzFunctionForBugDetection(originalFuzzFn) {
    if (originalFuzzFn.length === 1) {
        return (data) => {
            let fuzzTargetError;
            let result;
            try {
                result = originalFuzzFn(data);
                // Explicitly set promise handlers to process findings, but still return
                // the fuzz target result directly, so that sync execution is still
                // possible.
                if (result instanceof Promise) {
                    result = result.then((result) => {
                        return throwIfError() ?? result;
                    }, (reason) => {
                        return throwIfError(reason);
                    });
                }
            }
            catch (e) {
                fuzzTargetError = e;
            }
            return throwIfError(fuzzTargetError) ?? result;
        };
    }
    else {
        return (data, done) => {
            try {
                // Return result of fuzz target to enable sanity checks in C++ part.
                return originalFuzzFn(data, (err) => {
                    const finding = (0, bug_detectors_1.getFirstFinding)();
                    if (finding !== undefined) {
                        (0, bug_detectors_1.clearFirstFinding)();
                    }
                    done(finding ?? err);
                });
            }
            catch (e) {
                throwIfError(e);
            }
        };
    }
}
exports.wrapFuzzFunctionForBugDetection = wrapFuzzFunctionForBugDetection;
function throwIfError(fuzzTargetError) {
    const error = (0, bug_detectors_1.getFirstFinding)();
    if (error !== undefined) {
        // The `firstFinding` is a global variable: we need to clear it after each fuzzing iteration.
        (0, bug_detectors_1.clearFirstFinding)();
        throw error;
    }
    else if (fuzzTargetError) {
        throw fuzzTargetError;
    }
    return undefined;
}
async function importModule(name) {
    return import(name);
}
function ensureFilepath(filePath) {
    if (!filePath) {
        throw Error("Empty filepath provided");
    }
    const absolutePath = path_1.default.isAbsolute(filePath)
        ? filePath
        : path_1.default.join(process.cwd(), filePath);
    // file: schema is required on Windows
    const fullPath = "file://" + absolutePath;
    return [".js", ".mjs", ".cjs"].some((suffix) => fullPath.endsWith(suffix))
        ? fullPath
        : fullPath + ".js";
}
exports.ensureFilepath = ensureFilepath;
var jazzer_1 = require("./jazzer");
Object.defineProperty(exports, "jazzer", { enumerable: true, get: function () { return jazzer_1.jazzer; } });
var FuzzedDataProvider_1 = require("./FuzzedDataProvider");
Object.defineProperty(exports, "FuzzedDataProvider", { enumerable: true, get: function () { return FuzzedDataProvider_1.FuzzedDataProvider; } });
//# sourceMappingURL=core.js.map