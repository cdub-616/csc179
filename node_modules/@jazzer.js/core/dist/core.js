"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuzzedDataProvider = exports.jazzer = exports.ensureFilepath = exports.startFuzzingNoInit = exports.startFuzzing = exports.registerGlobals = exports.initFuzzing = void 0;
const path_1 = __importDefault(require("path"));
const process = __importStar(require("process"));
const tmp = __importStar(require("tmp"));
const fs = __importStar(require("fs"));
const fuzzer = __importStar(require("@jazzer.js/fuzzer"));
const hooking = __importStar(require("@jazzer.js/hooking"));
const hooking_1 = require("@jazzer.js/hooking");
const instrumentor_1 = require("@jazzer.js/instrumentor");
// Remove temporary files on exit
tmp.setGracefulCleanup();
// libFuzzer uses exit code 77 in case of a crash, so use a similar one for
// failed error expectations.
const ERROR_EXPECTED_CODE = 0;
const ERROR_UNEXPECTED_CODE = 78;
async function initFuzzing(options) {
    registerGlobals();
    await Promise.all(options.customHooks.map(importModule));
    if (!options.dryRun) {
        (0, instrumentor_1.registerInstrumentor)(new instrumentor_1.Instrumentor(options.includes, options.excludes, options.idSyncFile !== undefined
            ? new instrumentor_1.FileSyncIdStrategy(options.idSyncFile)
            : new instrumentor_1.MemorySyncIdStrategy()));
    }
}
exports.initFuzzing = initFuzzing;
function registerGlobals() {
    globalThis.Fuzzer = fuzzer.fuzzer;
    //TODO make sure that all sanitizers are registered at this point
    globalThis.HookManager = hooking.hookManager;
}
exports.registerGlobals = registerGlobals;
async function startFuzzing(options) {
    await initFuzzing(options);
    const fuzzFn = await loadFuzzFunction(options);
    await startFuzzingNoInit(fuzzFn, options).then(() => {
        stopFuzzing(undefined, options.expectedErrors);
    }, (err) => {
        stopFuzzing(err, options.expectedErrors);
    });
}
exports.startFuzzing = startFuzzing;
async function startFuzzingNoInit(fuzzFn, options) {
    const fuzzerOptions = buildFuzzerOptions(options);
    const fuzzerFn = options.sync
        ? Fuzzer.startFuzzing
        : Fuzzer.startFuzzingAsync;
    // Wrap the potentially sync fuzzer call, so that resolve and exception
    // handlers are always executed.
    return Promise.resolve().then(() => fuzzerFn(fuzzFn, fuzzerOptions));
}
exports.startFuzzingNoInit = startFuzzingNoInit;
function prepareLibFuzzerArg0(fuzzerOptions) {
    // When we run in a libFuzzer mode that spawns subprocesses, we create a wrapper script
    // that can be used as libFuzzer's argv[0]. In the fork mode, the main libFuzzer process
    // uses argv[0] to spawn further processes that perform the actual fuzzing.
    const libFuzzerSpawnsProcess = fuzzerOptions.some((flag) => flag.startsWith("-fork=") ||
        flag.startsWith("-jobs=") ||
        flag.startsWith("-merge="));
    if (!libFuzzerSpawnsProcess) {
        // Return a fake argv[0] to start the fuzzer if libFuzzer does not spawn new processes.
        return "unused_arg0_report_a_bug_if_you_see_this";
    }
    else {
        // Create a wrapper script and return its path.
        return createWrapperScript(fuzzerOptions);
    }
}
function createWrapperScript(fuzzerOptions) {
    const jazzerArgs = process.argv.filter((arg) => arg !== "--" && fuzzerOptions.indexOf(arg) === -1);
    if (jazzerArgs.indexOf("--id_sync_file") === -1) {
        const idSyncFile = tmp.fileSync({
            mode: 0o600,
            prefix: "jazzer.js",
            postfix: "idSync",
        });
        jazzerArgs.push("--id_sync_file", idSyncFile.name);
        fs.closeSync(idSyncFile.fd);
    }
    const isWindows = process.platform === "win32";
    const scriptContent = `${isWindows ? "@echo off" : "#!/usr/bin/env sh"}
cd "${process.cwd()}"
${jazzerArgs.map((s) => '"' + s + '"').join(" ")} -- ${isWindows ? "%*" : "$@"}
`;
    const scriptTempFile = tmp.fileSync({
        mode: 0o700,
        prefix: "jazzer.js",
        postfix: "libfuzzer" + (isWindows ? ".bat" : ".sh"),
    });
    fs.writeFileSync(scriptTempFile.name, scriptContent);
    fs.closeSync(scriptTempFile.fd);
    return scriptTempFile.name;
}
function stopFuzzing(err, expectedErrors) {
    if (process.env.JAZZER_DEBUG) {
        hooking_1.trackedHooks.categorizeUnknown(HookManager.hooks).print();
    }
    // No error found, check if one is expected.
    if (!err) {
        if (expectedErrors.length) {
            console.error(`ERROR: Received no error, but expected one of [${expectedErrors}].`);
            Fuzzer.stopFuzzingAsync(ERROR_UNEXPECTED_CODE);
        }
        return;
    }
    // Error found and expected, check if it's one of the expected ones.
    if (expectedErrors.length) {
        const name = errorName(err);
        if (expectedErrors.includes(name)) {
            console.error(`INFO: Received expected error "${name}".`);
            Fuzzer.stopFuzzingAsync(ERROR_EXPECTED_CODE);
        }
        else {
            printError(err);
            console.error(`ERROR: Received error "${name}" is not in expected errors [${expectedErrors}].`);
            Fuzzer.stopFuzzingAsync(ERROR_UNEXPECTED_CODE);
        }
        return;
    }
    // Error found, but no specific one expected. This case is used for normal
    // fuzzing runs, so no dedicated exit code is given to the stop fuzzing function.
    printError(err);
    Fuzzer.stopFuzzingAsync();
}
function errorName(error) {
    if (error instanceof Error) {
        // error objects
        return error.name;
    }
    else if (typeof error !== "object") {
        // primitive types
        return String(error);
    }
    else {
        // Arrays and objects can not be converted to a proper name and so
        // not be stated as expected error.
        return "unknown";
    }
}
function printError(error) {
    let errorMessage = `==${process.pid}== Uncaught Exception: Jazzer.js: `;
    if (error instanceof Error) {
        errorMessage += error.message;
        console.log(errorMessage);
        if (error.stack) {
            console.log(cleanStack(error.stack));
        }
    }
    else if (typeof error === "string" || error instanceof String) {
        errorMessage += error;
        console.log(errorMessage);
    }
    else {
        errorMessage += "unknown";
        console.log(errorMessage);
    }
}
function cleanStack(stack) {
    const result = [];
    for (const line of stack.split("\n")) {
        if (line.includes("startFuzzing") && line.includes("jazzer.js")) {
            break;
        }
        result.push(line);
    }
    return result.join("\n");
}
function buildFuzzerOptions(options) {
    if (!options || !options.fuzzerOptions) {
        return [];
    }
    // Last occurrence of a parameter is used.
    let opts = options.fuzzerOptions;
    if (options.dryRun) {
        opts = opts.concat("-runs=0");
    }
    if (options.timeout != undefined) {
        const inSeconds = options.timeout / 1000;
        opts = opts.concat(`-timeout=${inSeconds}`);
    }
    return [prepareLibFuzzerArg0(opts), ...opts];
}
async function loadFuzzFunction(options) {
    const fuzzTarget = await importModule(options.fuzzTarget);
    if (!fuzzTarget) {
        throw new Error(`${options.fuzzTarget} could not be imported successfully"`);
    }
    const fuzzFn = fuzzTarget[options.fuzzEntryPoint];
    if (typeof fuzzFn !== "function") {
        throw new Error(`${options.fuzzTarget} does not export function "${options.fuzzEntryPoint}"`);
    }
    return fuzzFn;
}
async function importModule(name) {
    return import(name);
}
function ensureFilepath(filePath) {
    if (!filePath) {
        throw Error("Empty filepath provided");
    }
    // file: schema is required on Windows
    const fullPath = "file://" + path_1.default.join(process.cwd(), filePath);
    return [".js", ".mjs", ".cjs"].some((suffix) => fullPath.endsWith(suffix))
        ? fullPath
        : fullPath + ".js";
}
exports.ensureFilepath = ensureFilepath;
var jazzer_1 = require("./jazzer");
Object.defineProperty(exports, "jazzer", { enumerable: true, get: function () { return jazzer_1.jazzer; } });
var FuzzedDataProvider_1 = require("./FuzzedDataProvider");
Object.defineProperty(exports, "FuzzedDataProvider", { enumerable: true, get: function () { return FuzzedDataProvider_1.FuzzedDataProvider; } });
//# sourceMappingURL=core.js.map