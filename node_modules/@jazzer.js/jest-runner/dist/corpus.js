"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Corpus = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
class Corpus {
    static defaultCorpusDirectory = ".cifuzz-corpus";
    // Directory containing manually generated user seeds and found
    // fuzzer inputs (crash, timeout, ...).
    _seedInputsDirectory;
    // Directory containing runtime generated fuzzer inputs.
    _generatedInputsDirectory;
    constructor(testSourceFilePath, testJestPathElements) {
        this._seedInputsDirectory = directoryPathForTest(testSourceFilePath, testJestPathElements);
        this._generatedInputsDirectory = directoryPathForTest(testSourceFilePath, testJestPathElements, Corpus.defaultCorpusDirectory);
        this.createMissingDirectories();
    }
    get seedInputsDirectory() {
        return this._seedInputsDirectory;
    }
    get generatedInputsDirectory() {
        return this._generatedInputsDirectory;
    }
    inputsPaths() {
        return fs_1.default
            .readdirSync(this._seedInputsDirectory)
            .filter((entry) => !fs_1.default
            .lstatSync(path_1.default.join(this.seedInputsDirectory, entry))
            .isDirectory())
            .map((file) => [file, path_1.default.join(this._seedInputsDirectory, file)]);
    }
    createMissingDirectories() {
        fs_1.default.mkdirSync(this._seedInputsDirectory, { recursive: true });
        fs_1.default.mkdirSync(this._generatedInputsDirectory, { recursive: true });
    }
}
exports.Corpus = Corpus;
const directoryPathForTest = (testSourceFilePath, testJestPathElements, addToProjectRoot = "") => {
    const rootDirectory = buildRootDirectory(testSourceFilePath, addToProjectRoot);
    const safeTestJestPathElements = testJestPathElements.map(replaceSpacesWithUnderscore);
    return path_1.default.join(rootDirectory, ...safeTestJestPathElements, path_1.default.sep);
};
const buildRootDirectory = (testSourceFilePath, projectCorpusRoot) => {
    const inputsRoot = path_1.default.parse(testSourceFilePath);
    const testName = inputsRoot.name;
    let mainDir = inputsRoot.dir;
    if (projectCorpusRoot !== "") {
        // looking for the root directory of the project
        mainDir = path_1.default.join(findDirectoryWithPackageJson(inputsRoot).dir, projectCorpusRoot, testName);
    }
    else {
        mainDir = path_1.default.join(inputsRoot.dir, testName);
    }
    return mainDir;
};
const findDirectoryWithPackageJson = (directory) => {
    while (!fs_1.default.readdirSync(directory.dir).includes("package.json")) {
        directory = path_1.default.parse(directory.dir);
        if (directory.dir === directory.root) {
            throw new Error("Could not find package.json in any parent directory");
        }
    }
    return directory;
};
const replaceSpacesWithUnderscore = (s) => {
    return s.replace(/ /g, "_");
};
//# sourceMappingURL=corpus.js.map