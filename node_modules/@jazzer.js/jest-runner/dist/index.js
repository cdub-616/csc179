"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const jest_runner_1 = require("jest-runner");
const worker_1 = require("./worker");
const core_1 = require("@jazzer.js/core");
const config_1 = require("./config");
const errorUtils_1 = require("./errorUtils");
class FuzzRunner extends jest_runner_1.CallbackTestRunner {
    constructor(globalConfig, context) {
        super(globalConfig, context);
        (0, core_1.registerGlobals)();
    }
    async runTests(tests, watcher, onStart, onResult, onFailure, options // eslint-disable-line @typescript-eslint/no-unused-vars
    ) {
        const config = (0, config_1.loadConfig)();
        (0, core_1.initFuzzing)(config);
        return this.#runTestsInBand(tests, watcher, onStart, onResult, onFailure);
    }
    async #runTestsInBand(tests, watcher, onStart, onResult, onFailure) {
        process.env.JEST_WORKER_ID = "1";
        return tests.reduce((promise, test) => {
            return promise.then(async () => {
                if (watcher.isInterrupted()) {
                    throw new CancelRun();
                }
                // Execute every test in a dedicated worker instance.
                // Currently, this is only in band but the structure supports parallel
                // execution in the future.
                await onStart(test);
                const worker = new worker_1.JazzerWorker();
                return worker.run(test, this._globalConfig).then((result) => onResult(test, result), (error) => {
                    error.stack = (0, errorUtils_1.cleanupJestRunnerStack)(error.stack);
                    onFailure(test, error);
                });
            });
        }, Promise.resolve());
    }
}
class CancelRun extends Error {
    constructor(message) {
        super(message);
        this.name = "CancelRun";
    }
}
exports.default = FuzzRunner;
//# sourceMappingURL=index.js.map