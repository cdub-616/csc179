"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JazzerWorker = void 0;
const perf_hooks_1 = require("perf_hooks");
const expect_1 = require("@jest/expect");
const circus = __importStar(require("jest-circus"));
const jest_message_util_1 = require("jest-message-util");
const util_1 = require("util");
const fuzz_1 = require("./fuzz");
const errorUtils_1 = require("./errorUtils");
const transform_1 = require("@jest/transform");
function isGeneratorFunction(obj) {
    return (!!obj &&
        typeof obj.next === "function" &&
        typeof obj[Symbol.iterator] === "function");
}
class JazzerWorker {
    static #workerInitialized = false;
    static #currentTestPath = "";
    defaultTimeout = 5000; // Default Jest timeout
    #testSummary;
    #testResults;
    constructor() {
        this.#testSummary = {
            passes: 0,
            failures: 0,
            pending: 0,
            start: 0,
            end: 0,
        };
        this.#testResults = [];
    }
    static get currentTestPath() {
        return this.#currentTestPath;
    }
    async initialize(test) {
        if (JazzerWorker.#workerInitialized) {
            return;
        }
        JazzerWorker.#workerInitialized = true;
        for (const file of test.context.config.setupFiles) {
            const { default: setup } = await this.importFile(file);
            setup();
        }
        JazzerWorker.setupGlobal();
        for (const file of test.context.config.setupFilesAfterEnv) {
            const { default: setup } = await this.importFile(file);
            setup();
        }
    }
    static setupGlobal() {
        // @ts-ignore
        globalThis.expect = expect_1.jestExpect;
        // @ts-ignore
        globalThis.test = circus.test;
        // @ts-ignore
        globalThis.test.fuzz = fuzz_1.fuzz;
        // @ts-ignore
        globalThis.test.skip.fuzz = fuzz_1.skip;
        // @ts-ignore
        globalThis.it = circus.it;
        // @ts-ignore
        globalThis.it.fuzz = fuzz_1.fuzz;
        // @ts-ignore
        globalThis.it.skip.fuzz = fuzz_1.skip;
        // @ts-ignore
        globalThis.describe = circus.describe;
        // @ts-ignore
        globalThis.beforeAll = circus.beforeAll;
        // @ts-ignore
        globalThis.afterAll = circus.afterAll;
        // @ts-ignore
        globalThis.beforeEach = circus.beforeEach;
        // @ts-ignore
        globalThis.afterEach = circus.afterEach;
    }
    async run(test, config) {
        JazzerWorker.#currentTestPath = test.path;
        await this.initialize(test);
        const state = await this.loadTests(test);
        this.#testSummary.start = perf_hooks_1.performance.now();
        await this.runDescribeBlock(state.rootDescribeBlock, state.hasFocusedTests, config.testNamePattern ?? "");
        this.#testSummary.end = perf_hooks_1.performance.now();
        const result = this.testResult(test);
        result.failureMessage = (0, jest_message_util_1.formatResultsErrors)(result.testResults, test.context.config, config, test.path);
        return result;
    }
    async loadTests(test) {
        circus.resetState();
        // Don't cache transformed files, as that will interfere with the internal
        // transformations. Config is read only, so a copy is needed.
        const config = { ...test.context.config };
        config.cache = false;
        const transformer = await (0, transform_1.createScriptTransformer)(config);
        await transformer.requireAndTranspileModule(test.path);
        return circus.getState();
    }
    async runDescribeBlock(block, hasFocusedTests, testNamePattern, ancestors = []) {
        const adjustedPattern = this.adjustTestPattern(ancestors, testNamePattern);
        await this.runHooks("beforeAll", block);
        for (const child of block.children) {
            const nextAncestors = ancestors.concat(child.name);
            if (child.mode === "skip" ||
                (child.type === "test" &&
                    this.shouldSkipTest(nextAncestors, adjustedPattern))) {
                this.#testSummary.pending++;
                this.#testResults.push({
                    ancestors,
                    title: child.name,
                    errors: [],
                    skipped: true,
                });
            }
            else if (child.type === "describeBlock") {
                await this.runHooks("beforeEach", block, true);
                await this.runDescribeBlock(child, hasFocusedTests, testNamePattern, nextAncestors);
                await this.runHooks("afterEach", block, true);
            }
            else if (child.type === "test") {
                await this.runHooks("beforeEach", block, true);
                await this.runTestEntry(child, ancestors);
                await this.runHooks("afterEach", block, true);
            }
        }
        await this.runHooks("afterAll", block);
    }
    async runTestEntry(testEntry, ancestors = []) {
        expect_1.jestExpect.setState({
            suppressedErrors: [],
            currentTestName: this.fullTestPath(ancestors.concat(testEntry.name)),
        });
        let skipTest = false;
        let errors = [];
        await Promise.resolve()
            // @ts-ignore
            .then(testEntry.fn)
            .catch((error) => {
            // Mark fuzzer tests as skipped and not as error.
            if (error instanceof fuzz_1.FuzzerStartError) {
                skipTest = true;
            }
            errors.push(error);
        });
        // Get suppressed errors from ``jest-matchers`` that weren't thrown during
        // test execution and add them to the test result, potentially failing
        // a passing test.
        const state = expect_1.jestExpect.getState();
        if (state.suppressedErrors.length > 0) {
            errors.unshift(...state.suppressedErrors);
        }
        errors = errors.map((e) => {
            if (e && e.stack) {
                e.stack = (0, errorUtils_1.cleanupJestRunnerStack)(e.stack);
            }
            return e;
        });
        if (skipTest) {
            this.#testSummary.pending++;
        }
        else if (errors.length > 0) {
            this.#testSummary.failures++;
        }
        else {
            this.#testSummary.passes++;
        }
        this.#testResults.push({
            ancestors,
            title: testEntry.name,
            skipped: skipTest,
            errors,
        });
    }
    async runHooks(hookType, block, shouldRunInAncestors = false) {
        const hooks = shouldRunInAncestors && block.parent ? block.parent.hooks : block.hooks;
        for (const hook of hooks.filter((hook) => hook.type === hookType)) {
            const timeout = hook.timeout ?? this.defaultTimeout;
            await this.runHook(block, hook, timeout);
        }
    }
    async runHook(block, hook, timeout) {
        let timeoutID;
        return new Promise((resolve, reject) => {
            timeoutID = setTimeout(() => {
                reject((0, errorUtils_1.removeTopFramesFromError)(new Error(`Exceeded timeout of ${timeout} ms for "${hook.type}" of "${block.name}".\nIncrease the timeout value, if this is a long-running test.`), 1));
            }, timeout);
            this.executeHook(block, hook, resolve, reject);
        }).then((value) => {
            // Remove timeout to enable clean shutdown.
            timeoutID?.unref?.();
            clearTimeout(timeoutID);
            return value;
        }, (error) => {
            // Remove timeout to enable clean shutdown.
            timeoutID?.unref?.();
            clearTimeout(timeoutID);
            throw error;
        });
    }
    executeHook(block, hook, resolve, reject) {
        let result;
        if (hook.fn.length > 0) {
            result = new Promise((resolve, reject) => {
                let doneCalled = false;
                const done = (doneMsg) => {
                    if (doneCalled) {
                        // As the promise was already resolved in the last invocation, and
                        // there could be quite some time until this one, there is not much we
                        // can do besides printing an error message.
                        console.error(`Expected done to be called once, but it was called multiple times in "${hook.type}" of "${block.name}".`);
                    }
                    doneCalled = true;
                    if (typeof doneMsg === "string") {
                        reject((0, errorUtils_1.removeTopFramesFromError)(new Error(`Failed: ${doneMsg}`), 1));
                    }
                    else if (doneMsg) {
                        reject(doneMsg);
                    }
                    else {
                        resolve(undefined);
                    }
                };
                const hookResult = hook.fn(done);
                // These checks are executed before the callback, hence rejecting
                // the promise is still possible.
                if (hookResult instanceof Promise) {
                    reject((0, errorUtils_1.removeTopFramesFromError)(new Error(`Using done callback in async "${hook.type}" hook of "${block.name}" is not allowed.`), 1));
                }
                else if (isGeneratorFunction(hookResult)) {
                    reject((0, errorUtils_1.removeTopFramesFromError)(new Error(`Generators are currently not supported by Jazzer.js but used in "${hook.type}" of "${block.name}".`), 1));
                }
            });
        }
        else {
            // @ts-ignore
            result = hook.fn();
        }
        if (result instanceof Promise) {
            result.then(resolve, reject);
        }
        else if (isGeneratorFunction(result)) {
            reject((0, errorUtils_1.removeTopFramesFromError)(new Error(`Generators are currently not supported by Jazzer.js but used in "${hook.type}" of "${block.name}".`), 1));
        }
        else {
            resolve(result);
        }
    }
    testResult(test) {
        const runtime = this.#testSummary.end - this.#testSummary.start;
        return {
            coverage: globalThis.__coverage__,
            console: undefined,
            failureMessage: this.#testResults
                .filter((t) => t.errors.length > 0)
                .map(this.failureToString)
                .join("\n"),
            leaks: false,
            numFailingTests: this.#testSummary.failures,
            numPassingTests: this.#testSummary.passes,
            numPendingTests: this.#testSummary.pending,
            numTodoTests: 0,
            openHandles: [],
            perfStats: {
                start: this.#testSummary.start,
                end: this.#testSummary.end,
                runtime: Math.round(runtime),
                slow: runtime / 1000 > test.context.config.slowTestThreshold,
            },
            skipped: this.#testResults.every((t) => t.skipped),
            snapshot: {
                added: 0,
                fileDeleted: false,
                matched: 0,
                unchecked: 0,
                uncheckedKeys: [],
                unmatched: 0,
                updated: 0,
            },
            testExecError: undefined,
            testFilePath: test.path,
            testResults: this.#testResults.map((testResult) => {
                return {
                    ancestorTitles: testResult.ancestors,
                    duration: testResult.duration ? testResult.duration / 1000 : null,
                    failureDetails: testResult.errors,
                    failureMessages: testResult.errors.length
                        ? [this.failureToString(testResult)]
                        : [],
                    fullName: testResult.title,
                    numPassingAsserts: testResult.errors.length > 0 ? 1 : 0,
                    status: testResult.skipped
                        ? "pending"
                        : testResult.errors.length > 0
                            ? "failed"
                            : "passed",
                    title: testResult.title,
                };
            }),
        };
    }
    failureToString(result) {
        return (result.errors
            .map((error) => (0, util_1.inspect)(error).replace(/^/gm, "    "))
            .join("\n") + "\n");
    }
    /**
     *  If we always remove the dollar sign, then the runner will run all tests matching to a test name.
     *  For that reason, we only remove the dollar sign if the test name matches exactly.
     */
    adjustTestPattern(ancestors, testNamePattern) {
        // IntelliJ interprets our fuzz extension as a test and thus appends a dollar sign
        // to the fuzz test pattern when started from the IDE. This is fine for the fuzzing mode
        // where we register a normal test. However, in the regression mode, we register a
        // describe-block. This results in the child tests being skipped.
        if (testNamePattern.endsWith("$") &&
            this.doesMatch(ancestors, testNamePattern)) {
            return testNamePattern.slice(0, -1);
        }
        return testNamePattern;
    }
    shouldSkipTest(ancestors, testNamePattern) {
        return !this.doesMatch(ancestors, testNamePattern);
    }
    fullTestPath(elements) {
        return elements.join(" ");
    }
    doesMatch(ancestors, testNamePattern) {
        const testPath = this.fullTestPath(ancestors);
        if (testNamePattern === "") {
            return true;
        }
        const testNamePatternRE = new RegExp(testNamePattern, "i");
        return testNamePatternRE.test(testPath);
    }
    async importFile(file) {
        // file: schema is required on Windows
        if (!file.startsWith("file://")) {
            file = "file://" + file;
        }
        return await import(file);
    }
}
exports.JazzerWorker = JazzerWorker;
//# sourceMappingURL=worker.js.map