"use strict";
/*
 * Copyright 2022 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInRegressionMode = exports.runInFuzzingMode = exports.fuzz = exports.skip = exports.FuzzerStartError = exports.FuzzerError = void 0;
const config_1 = require("./config");
const worker_1 = require("./worker");
const corpus_1 = require("./corpus");
const circus = __importStar(require("jest-circus"));
const fs = __importStar(require("fs"));
const errorUtils_1 = require("./errorUtils");
const core_1 = require("@jazzer.js/core");
// Globally track when the fuzzer is started in fuzzing mode.
let fuzzerStarted = false;
// Indicate that something went wrong executing the fuzzer.
class FuzzerError extends Error {
}
exports.FuzzerError = FuzzerError;
// Error indicating that the fuzzer was already started.
class FuzzerStartError extends FuzzerError {
}
exports.FuzzerStartError = FuzzerStartError;
// Use Jests global object definition.
const g = globalThis;
const skip = (name) => {
    g.test.skip(toTestName(name), () => {
        return;
    });
};
exports.skip = skip;
const fuzz = (name, fn, timeout) => {
    const testName = toTestName(name);
    // Request the current test file path from the worker to create appropriate
    // corpus directory hierarchies. It is set by the worker that imports the
    // actual test file and changes during execution of multiple test files.
    const testFile = worker_1.JazzerWorker.currentTestPath;
    // Build up the names of test block elements (describe, test, it) pointing
    // to the currently executed fuzz function, based on the circus runner state.
    // The used state changes during test file import but, at this point,
    // points to the element containing the fuzz function.
    const testStatePath = currentTestStatePath(testName);
    const corpus = new corpus_1.Corpus(testFile, testStatePath);
    const fuzzingConfig = (0, config_1.loadConfig)();
    // Timeout priority is: test timeout > config timeout > default timeout.
    if (!timeout) {
        timeout = fuzzingConfig.timeout;
    }
    else {
        fuzzingConfig.timeout = timeout;
    }
    const wrappedFn = (0, core_1.wrapFuzzFunctionForBugDetection)(fn);
    if (fuzzingConfig.dryRun) {
        (0, exports.runInRegressionMode)(name, wrappedFn, corpus, timeout);
    }
    else {
        (0, exports.runInFuzzingMode)(name, wrappedFn, corpus, fuzzingConfig);
    }
};
exports.fuzz = fuzz;
const runInFuzzingMode = (name, fn, corpus, config) => {
    config.fuzzerOptions.unshift(corpus.seedInputsDirectory);
    config.fuzzerOptions.unshift(corpus.generatedInputsDirectory);
    config.fuzzerOptions.push("-artifact_prefix=" + corpus.seedInputsDirectory);
    g.test(name, () => {
        // Fuzzing is only allowed to start once in a single nodejs instance.
        if (fuzzerStarted) {
            const message = `Fuzzer already started. Please provide single fuzz test using --testNamePattern. Skipping test "${toTestName(name)}"`;
            const error = new FuzzerStartError(message);
            // Remove stack trace as it is shown in the CLI / IDE and points to internal code.
            error.stack = undefined;
            throw error;
        }
        fuzzerStarted = true;
        return (0, core_1.startFuzzingNoInit)(fn, config);
    });
};
exports.runInFuzzingMode = runInFuzzingMode;
const runInRegressionMode = (name, fn, corpus, timeout) => {
    g.describe(name, () => {
        const inputsPaths = corpus.inputsPaths();
        // Mark fuzz tests with empty inputs as skipped to suppress Jest error.
        if (inputsPaths.length === 0) {
            g.test.skip(name, () => {
                return;
            });
            return;
        }
        // Execute the fuzz test with each input file as no libFuzzer is required.
        // Custom hooks are already registered via the jest-runner.
        inputsPaths.forEach(([seed, path]) => {
            g.test(seed, async () => {
                const content = await fs.promises.readFile(path);
                let timeoutID;
                return new Promise((resolve, reject) => {
                    // Register a timeout for every fuzz test function invocation.
                    timeoutID = setTimeout(() => {
                        reject(new FuzzerError(`Timeout reached ${timeout}`));
                    }, timeout);
                    // Fuzz test expects a done callback, if more than one parameter is specified.
                    if (fn.length > 1) {
                        return doneCallbackPromise(fn, content, resolve, reject);
                    }
                    else {
                        // Support sync and async fuzz tests.
                        return Promise.resolve()
                            .then(() => fn(content))
                            .then(resolve, reject);
                    }
                }).then((value) => {
                    // Remove timeout to enable clean shutdown.
                    timeoutID?.unref?.();
                    clearTimeout(timeoutID);
                    return value;
                }, (error) => {
                    // Remove timeout to enable clean shutdown.
                    timeoutID?.unref?.();
                    clearTimeout(timeoutID);
                    throw error;
                });
            });
        });
    });
};
exports.runInRegressionMode = runInRegressionMode;
const doneCallbackPromise = (fn, content, resolve, reject) => {
    try {
        let doneCalled = false;
        const doneCallback = (e) => {
            if (doneCalled) {
                // As the promise was already resolved in the last invocation, and
                // there could be quite some time until this one, there is not much we
                // can do besides printing an error message.
                console.error("Expected done to be called once, but it was called multiple times.");
            }
            doneCalled = true;
            let error;
            if (typeof e === "string") {
                error = (0, errorUtils_1.removeTopFramesFromError)(new Error(e), 1);
            }
            else {
                error = e;
            }
            error ? reject(error) : resolve(undefined);
        };
        const result = fn(content, doneCallback);
        // Expecting a done callback, but returning a promise, is invalid. This is
        // already prevented by TypeScript, but we should still check for this
        // situation due to untyped JavaScript fuzz tests.
        // @ts-ignore
        if (result && typeof result.then === "function") {
            reject(new FuzzerError("Either async or done callback based fuzz tests allowed"));
        }
    }
    catch (e) {
        reject(e);
    }
};
const toTestName = (name) => {
    switch (typeof name) {
        case "string":
            return name;
        case "number":
            return `${name}`;
        case "function":
            if (name.name) {
                return name.name;
            }
    }
    throw new FuzzerError(`Invalid test name "${name}"`);
};
const currentTestStatePath = (testName) => {
    const elements = [testName];
    let describeBlock = circus.getState().currentDescribeBlock;
    while (describeBlock !== circus.getState().rootDescribeBlock) {
        elements.unshift(describeBlock.name);
        if (describeBlock.parent) {
            describeBlock = describeBlock.parent;
        }
    }
    return elements;
};
//# sourceMappingURL=fuzz.js.map